import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAI } from 'openai';
import { createClient } from '@supabase/supabase-js';

// åˆå§‹åŒ–å®¢æˆ·ç«¯
const pinecone = new Pinecone({
  apiKey: process.env.PINECONE_API_KEY!
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!
});

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export interface IllustrationMatch {
  id: string;
  filename: string;
  bookTitle: string;
  description: string;
  imageUrl: string;
  similarity: number;
  metadata: {
    ageOrientation?: string;
    textTypeFit?: string;
    bookTheme?: string;
    keywords?: string[];
  };
}

export interface TextContent {
  content: string;
  targetAge?: string;
  contentType?: string;
  theme?: string;
  keywords?: string[];
}

/**
 * å°†æ–‡æ¡ˆå†…å®¹è½¬æ¢ä¸ºå‘é‡
 */
export async function textToVector(text: string): Promise<number[]> {
  try {
    const response = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: text,
    });
    
    return response.data[0].embedding;
  } catch (error) {
    console.error('æ–‡æœ¬å‘é‡åŒ–å¤±è´¥:', error);
    throw new Error('æ–‡æœ¬å‘é‡åŒ–å¤±è´¥');
  }
}

/**
 * æ™ºèƒ½åŒ¹é…æ–‡æ¡ˆä¸æ’å›¾
 */
export async function matchIllustrationsToText(
  textContent: TextContent,
  topK: number = 10
): Promise<IllustrationMatch[]> {
  try {
    const index = pinecone.index(process.env.PINECONE_INDEX_NAME!);
    
    // 1. å°†æ–‡æ¡ˆè½¬æ¢ä¸ºå‘é‡
    console.log('ğŸ”„ å°†æ–‡æ¡ˆè½¬æ¢ä¸ºå‘é‡...');
    const textVector = await textToVector(textContent.content);
    
    // 2. æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const queryOptions: any = {
      vector: textVector,
      topK: topK,
      includeMetadata: true,
      filter: {}
    };
    
    // 3. æ·»åŠ å¹´é¾„è¿‡æ»¤æ¡ä»¶
    if (textContent.targetAge) {
      queryOptions.filter.ageOrientation = { $eq: textContent.targetAge };
    }
    
    // 4. æ·»åŠ å†…å®¹ç±»å‹è¿‡æ»¤æ¡ä»¶
    if (textContent.contentType) {
      queryOptions.filter.textTypeFit = { $eq: textContent.contentType };
    }
    
    // 5. æ‰§è¡Œç›¸ä¼¼åº¦æœç´¢
    console.log('ğŸ” æ‰§è¡Œç›¸ä¼¼åº¦æœç´¢...');
    const queryResponse = await index.query(queryOptions);
    
    // 6. å¤„ç†æœç´¢ç»“æœ
    const matches: IllustrationMatch[] = queryResponse.matches.map(match => ({
      id: match.id,
      filename: match.metadata?.filename || '',
      bookTitle: match.metadata?.book_title || '',
      description: match.metadata?.description || '',
      imageUrl: match.metadata?.image_url || '',
      similarity: match.score || 0,
      metadata: {
        ageOrientation: match.metadata?.age_orientation,
        textTypeFit: match.metadata?.text_type_fit,
        bookTheme: match.metadata?.book_theme,
        keywords: match.metadata?.keywords || []
      }
    }));
    
    console.log(`âœ… æ‰¾åˆ° ${matches.length} ä¸ªåŒ¹é…çš„æ’å›¾`);
    return matches;
    
  } catch (error) {
    console.error('æ’å›¾åŒ¹é…å¤±è´¥:', error);
    throw new Error('æ’å›¾åŒ¹é…å¤±è´¥');
  }
}

/**
 * åŸºäºå…³é”®è¯çš„æ’å›¾æœç´¢
 */
export async function searchIllustrationsByKeywords(
  keywords: string[],
  targetAge?: string,
  contentType?: string,
  topK: number = 10
): Promise<IllustrationMatch[]> {
  try {
    const index = pinecone.index(process.env.PINECONE_INDEX_NAME!);
    
    // 1. å°†å…³é”®è¯ç»„åˆæˆæœç´¢æ–‡æœ¬
    const searchText = keywords.join(' ');
    const searchVector = await textToVector(searchText);
    
    // 2. æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const queryOptions: any = {
      vector: searchVector,
      topK: topK,
      includeMetadata: true,
      filter: {}
    };
    
    // 3. æ·»åŠ è¿‡æ»¤æ¡ä»¶
    if (targetAge) {
      queryOptions.filter.ageOrientation = { $eq: targetAge };
    }
    
    if (contentType) {
      queryOptions.filter.textTypeFit = { $eq: contentType };
    }
    
    // 4. æ‰§è¡Œæœç´¢
    const queryResponse = await index.query(queryOptions);
    
    // 5. å¤„ç†ç»“æœ
    const matches: IllustrationMatch[] = queryResponse.matches.map(match => ({
      id: match.id,
      filename: match.metadata?.filename || '',
      bookTitle: match.metadata?.book_title || '',
      description: match.metadata?.description || '',
      imageUrl: match.metadata?.image_url || '',
      similarity: match.score || 0,
      metadata: {
        ageOrientation: match.metadata?.age_orientation,
        textTypeFit: match.metadata?.text_type_fit,
        bookTheme: match.metadata?.book_theme,
        keywords: match.metadata?.keywords || []
      }
    }));
    
    return matches;
    
  } catch (error) {
    console.error('å…³é”®è¯æœç´¢å¤±è´¥:', error);
    throw new Error('å…³é”®è¯æœç´¢å¤±è´¥');
  }
}

/**
 * è·å–æ’å›¾è¯¦æƒ…
 */
export async function getIllustrationDetails(illustrationId: string): Promise<any> {
  try {
    const { data, error } = await supabase
      .from('illustrations')
      .select('*')
      .eq('id', illustrationId)
      .single();
    
    if (error) {
      throw new Error(`è·å–æ’å›¾è¯¦æƒ…å¤±è´¥: ${error.message}`);
    }
    
    return data;
  } catch (error) {
    console.error('è·å–æ’å›¾è¯¦æƒ…å¤±è´¥:', error);
    throw new Error('è·å–æ’å›¾è¯¦æƒ…å¤±è´¥');
  }
}

/**
 * æ‰¹é‡è·å–æ’å›¾ä¿¡æ¯
 */
export async function getIllustrationsBatch(illustrationIds: string[]): Promise<any[]> {
  try {
    const { data, error } = await supabase
      .from('illustrations')
      .select('*')
      .in('id', illustrationIds);
    
    if (error) {
      throw new Error(`æ‰¹é‡è·å–æ’å›¾å¤±è´¥: ${error.message}`);
    }
    
    return data || [];
  } catch (error) {
    console.error('æ‰¹é‡è·å–æ’å›¾å¤±è´¥:', error);
    throw new Error('æ‰¹é‡è·å–æ’å›¾å¤±è´¥');
  }
} 